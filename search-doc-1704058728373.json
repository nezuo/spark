[{"title":"Signal","type":0,"sectionRef":"#","url":"/spark/api/Signal","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Signal","url":"/spark/api/Signal#functions","content":" "},{"title":"connect​","type":1,"pageTitle":"Signal","url":"/spark/api/Signal#connect","content":"&lt;/&gt; Signal:connect(connection: function | thread) → () → ()-- A function that when called, disconnects the connection.  "},{"title":"Spark","type":0,"sectionRef":"#","url":"/spark/docs/intro","content":"Spark Spark is an input-action manager for Roblox. To get started, visit the Getting Started page.","keywords":""},{"title":"InputState","type":0,"sectionRef":"#","url":"/spark/api/InputState","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"InputState","url":"/spark/api/InputState#functions","content":" "},{"title":"new​","type":1,"pageTitle":"InputState","url":"/spark/api/InputState#new","content":"&lt;/&gt; InputState.new() → InputState Creates a new InputState.  "},{"title":"clear​","type":1,"pageTitle":"InputState","url":"/spark/api/InputState#clear","content":"&lt;/&gt; InputState:clear() → () This clears mouse wheel and mouse delta data so it doesn't persist across frames. This should be called once every frame after Actions:update is called. "},{"title":"Multiply2d","type":0,"sectionRef":"#","url":"/spark/api/Multiply2d","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Multiply2d","url":"/spark/api/Multiply2d#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Multiply2d","url":"/spark/api/Multiply2d#new","content":"&lt;/&gt; Multiply2d.new( input: Input2d, multiplier: Vector2 ) → Multiply2d Creates a new Multiply2d given a 2D input and multiplier. "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/spark/docs/GettingStarted","content":"Getting Started -- First we create the InputState object. This should only be created once. local inputState = InputState.new() -- Next, we create our Actions object. local actions = Actions.new({ &quot;jump&quot;, &quot;attack&quot;, &quot;move&quot; }) -- Next, we create our InputMap. This stores our mappings from inputs to actions. -- This object can be used for rebinding. local inputMap = InputMap.new() :insert(&quot;jump&quot;, Enum.KeyCode.Space, Enum.KeyCode.ButtonA) :insert(&quot;attack&quot;, Enum.UserInputType.MouseButton1, Enum.KeyCode.ButtonR1) :insert(&quot;move&quot;, VirtualAxis2d.wasd(), Enum.KeyCode.Thumbstick1) -- You need to update your Actions objects each frame before any code that reads action values. RunService:BindToRenderStep(&quot;Spark&quot;, Enum.RenderPriority.Input.Value, function() -- First we update our Actions object given the InputState and the associated InputMap. actions:update(inputState, inputMap) -- InputState:clear needs to be called after updating all Actions objects. -- It resets the values of the mouse wheel and mouse movement so they don't persist across frames. inputState:clear() end) ","keywords":""},{"title":"VirtualAxis2d","type":0,"sectionRef":"#","url":"/spark/api/VirtualAxis2d","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"VirtualAxis2d","url":"/spark/api/VirtualAxis2d#properties","content":" "},{"title":"up​","type":1,"pageTitle":"VirtualAxis2d","url":"/spark/api/VirtualAxis2d#up","content":"&lt;/&gt; VirtualAxis2d.up: Button?   "},{"title":"down​","type":1,"pageTitle":"VirtualAxis2d","url":"/spark/api/VirtualAxis2d#down","content":"&lt;/&gt; VirtualAxis2d.down: Button?   "},{"title":"left​","type":1,"pageTitle":"VirtualAxis2d","url":"/spark/api/VirtualAxis2d#left","content":"&lt;/&gt; VirtualAxis2d.left: Button?   "},{"title":"right​","type":1,"pageTitle":"VirtualAxis2d","url":"/spark/api/VirtualAxis2d#right","content":"&lt;/&gt; VirtualAxis2d.right: Button?  "},{"title":"Functions​","type":1,"pageTitle":"VirtualAxis2d","url":"/spark/api/VirtualAxis2d#functions","content":" "},{"title":"new​","type":1,"pageTitle":"VirtualAxis2d","url":"/spark/api/VirtualAxis2d#new","content":"&lt;/&gt; VirtualAxis2d.new(options: { up: Button?, down: Button?, left: Button?, right: Button? }) → VirtualAxis2d Creates a VirtualAxis2d with the corresponding options.  "},{"title":"arrowKeys​","type":1,"pageTitle":"VirtualAxis2d","url":"/spark/api/VirtualAxis2d#arrowKeys","content":"&lt;/&gt; VirtualAxis2d.arrowKeys() → VirtualAxis2d Creates a VirtualAxis2d corresponding to the arrow keys.  "},{"title":"wasd​","type":1,"pageTitle":"VirtualAxis2d","url":"/spark/api/VirtualAxis2d#wasd","content":"&lt;/&gt; VirtualAxis2d.wasd() → VirtualAxis2d Creates a VirtualAxis2d corresponding to the WASD keys.  "},{"title":"dPad​","type":1,"pageTitle":"VirtualAxis2d","url":"/spark/api/VirtualAxis2d#dPad","content":"&lt;/&gt; VirtualAxis2d.dPad() → VirtualAxis2d Creates a VirtualAxis2d corresponding to the DPad on gamepads. "},{"title":"Mobile","type":0,"sectionRef":"#","url":"/spark/docs/Mobile","content":"Mobile Spark allows you to activate an action manually. This is especially useful to implement mobile touch controls. For buttons, you can activate an action with Actions:hold. Here's how you might implement a mobile button: local imageButton = Instance.new(&quot;ImageButton&quot;) local hold = nil imageButton.InputBegan:Connect(function(inputObject) if inputObject.UserInputState ~= Enum.UserInputState.Begin then -- UserInputState will be Change if the touch was dragged onto the button. return end -- You can either check if inputObject.UserInputType == Enum.UserInputType.Touch or hide -- the button when touch isn't being used. if hold == nil then hold = { -- The hold method acts like a button press. It returns a function to stop the press. stopHold = actions:hold(&quot;attack&quot;), inputObject = inputObject, } end end) imageButton.InputEnded:Connect(function(inputObject) -- Only stop the hold if it's the same touch that started it. if hold ~= nil and hold.inputObject == inputObject then hold.stopHold() hold = nil end end) For 2D axis values like movement or camera movement, use Actions:move. local thumbstickDirection = Vector2.one -- Get this value from your thumbstick. -- This will increase the 2D axis value of the move action by thumbstickDirection. -- It's reset every time `Actions:update` is called, so you need to call it every frame. actions:move(&quot;move&quot;, thumbstickDirection) ","keywords":""},{"title":"Rebind","type":0,"sectionRef":"#","url":"/spark/api/Rebind","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Rebind","url":"/spark/api/Rebind#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Rebind","url":"/spark/api/Rebind#new","content":"&lt;/&gt; Rebind.new() → Rebind Creates a new Rebind. To query for a button, call Rebind:start.  "},{"title":"withDevices​","type":1,"pageTitle":"Rebind","url":"/spark/api/Rebind#withDevices","content":"&lt;/&gt; Rebind:withDevices(devices: {Device}) → Rebind-- Returns self "},{"title":"Types","type":1,"pageTitle":"Rebind","url":"/spark/api/Rebind##","content":""},{"title":"​","type":1,"pageTitle":"Rebind","url":"/spark/api/Rebind#Device","content":"type Device = &quot;Keyboard&quot; | &quot;Mouse&quot; | &quot;Gamepad&quot;  By default, inputs from all devices are included. When called, this method will only include the specified devices.  "},{"title":"withoutInputs​","type":1,"pageTitle":"Rebind","url":"/spark/api/Rebind#withoutInputs","content":"&lt;/&gt; Rebind:withoutInputs(inputs: {Button}) → Rebind-- Returns self Excludes inputs from being chosen.  "},{"title":"start​","type":1,"pageTitle":"Rebind","url":"/spark/api/Rebind#start","content":"&lt;/&gt; Rebind:start() → Promise&lt;Button&gt; Returns a Promise that resolves with the first Button the user presses. The promise can be cancelled if you no longer need the result. "},{"title":"VirtualAxis","type":0,"sectionRef":"#","url":"/spark/api/VirtualAxis","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"VirtualAxis","url":"/spark/api/VirtualAxis#properties","content":" "},{"title":"positive​","type":1,"pageTitle":"VirtualAxis","url":"/spark/api/VirtualAxis#positive","content":"&lt;/&gt; VirtualAxis.positive: Button?   "},{"title":"negative​","type":1,"pageTitle":"VirtualAxis","url":"/spark/api/VirtualAxis#negative","content":"&lt;/&gt; VirtualAxis.negative: Button?  "},{"title":"Functions​","type":1,"pageTitle":"VirtualAxis","url":"/spark/api/VirtualAxis#functions","content":" "},{"title":"new​","type":1,"pageTitle":"VirtualAxis","url":"/spark/api/VirtualAxis#new","content":"&lt;/&gt; VirtualAxis.new(options: { postive: Button?, negative: Button? }) → VirtualAxis Creates a VirtualAxis with the corresponding options.  "},{"title":"horizontalArrowKeys​","type":1,"pageTitle":"VirtualAxis","url":"/spark/api/VirtualAxis#horizontalArrowKeys","content":"&lt;/&gt; VirtualAxis.horizontalArrowKeys() → VirtualAxis Creates a VirtualAxis corresponding to the left and right arrow keys.  "},{"title":"verticalArrowKeys​","type":1,"pageTitle":"VirtualAxis","url":"/spark/api/VirtualAxis#verticalArrowKeys","content":"&lt;/&gt; VirtualAxis.verticalArrowKeys() → VirtualAxis Creates a VirtualAxis corresponding to the up and down arrow keys. "},{"title":"Spark","type":0,"sectionRef":"#","url":"/spark/api/Spark","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Spark","url":"/spark/api/Spark#types","content":" "},{"title":"Button​","type":1,"pageTitle":"Spark","url":"/spark/api/Spark#Button","content":"&lt;/&gt; type Button = Enum.KeyCode | Enum.UserInputType Enum.UserInputType must represent a button. Inputs like Enum.UserInputType.MouseMovement will not work as a button.  "},{"title":"Input2d​","type":1,"pageTitle":"Spark","url":"/spark/api/Spark#Input2d","content":"&lt;/&gt; type Input2d = Enum.UserInputType | VirtualAxis2d Enum.UserInputType must represent a 2D value. Inputs like Enum.UserInputType.MouseButton1 will not work as a 2D value.  "},{"title":"Input​","type":1,"pageTitle":"Spark","url":"/spark/api/Spark#Input","content":"&lt;/&gt; type Input = Enum.KeyCode | Enum.UserInputType | VirtualAxis | VirtualAxis2d | Multiply2d  "},{"title":"Properties​","type":1,"pageTitle":"Spark","url":"/spark/api/Spark#properties","content":" "},{"title":"Actions​","type":1,"pageTitle":"Spark","url":"/spark/api/Spark#Actions","content":"&lt;/&gt; Spark.Actions: Actions   "},{"title":"InputMap​","type":1,"pageTitle":"Spark","url":"/spark/api/Spark#InputMap","content":"&lt;/&gt; Spark.InputMap: InputMap   "},{"title":"InputState​","type":1,"pageTitle":"Spark","url":"/spark/api/Spark#InputState","content":"&lt;/&gt; Spark.InputState: InputState   "},{"title":"Multiply2d​","type":1,"pageTitle":"Spark","url":"/spark/api/Spark#Multiply2d","content":"&lt;/&gt; Spark.Multiply2d: Multiply2d   "},{"title":"Rebind​","type":1,"pageTitle":"Spark","url":"/spark/api/Spark#Rebind","content":"&lt;/&gt; Spark.Rebind: Rebind   "},{"title":"Signal​","type":1,"pageTitle":"Spark","url":"/spark/api/Spark#Signal","content":"&lt;/&gt; Spark.Signal: Signal   "},{"title":"VirtualAxis​","type":1,"pageTitle":"Spark","url":"/spark/api/Spark#VirtualAxis","content":"&lt;/&gt; Spark.VirtualAxis: VirtualAxis   "},{"title":"VirtualAxis2d​","type":1,"pageTitle":"Spark","url":"/spark/api/Spark#VirtualAxis2d","content":"&lt;/&gt; Spark.VirtualAxis2d: VirtualAxis2d  "},{"title":"InputMap","type":0,"sectionRef":"#","url":"/spark/api/InputMap","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"InputMap","url":"/spark/api/InputMap#properties","content":" "},{"title":"associatedGamepad​","type":1,"pageTitle":"InputMap","url":"/spark/api/InputMap#associatedGamepad","content":"&lt;/&gt; InputMap.associatedGamepad: Enum.UserInputType? If associatedGamepad is nil, the connected gamepad with the lowest number will be used. The Enum.UserInputType must represent a gamepad. "},{"title":"Functions​","type":1,"pageTitle":"InputMap","url":"/spark/api/InputMap#functions","content":" "},{"title":"new​","type":1,"pageTitle":"InputMap","url":"/spark/api/InputMap#new","content":"&lt;/&gt; InputMap.new() → InputMap Creates an empty InputMap.  "},{"title":"deserialize​","type":1,"pageTitle":"InputMap","url":"/spark/api/InputMap#deserialize","content":"&lt;/&gt; InputMap.deserialize(serialized: buffer) → InputMap Deserializes the buffer returned from InputMap:serialize back into an InputMap.  "},{"title":"insert​","type":1,"pageTitle":"InputMap","url":"/spark/api/InputMap#insert","content":"&lt;/&gt; InputMap:insert( action: string, ...: Input ) → InputMap-- Returns self Maps inputs to action. If an input is already mapped to the action, it won't be mapped again.  "},{"title":"remove​","type":1,"pageTitle":"InputMap","url":"/spark/api/InputMap#remove","content":"&lt;/&gt; InputMap:remove( action: string, input: Input ) → () Removes the mapping from input to action if it exists.  "},{"title":"get​","type":1,"pageTitle":"InputMap","url":"/spark/api/InputMap#get","content":"&lt;/&gt; InputMap:get(action: string) → {Input} Gets the inputs mapped to action.  "},{"title":"getByDevices​","type":1,"pageTitle":"InputMap","url":"/spark/api/InputMap#getByDevices","content":"&lt;/&gt; InputMap:getByDevices( action: string, devices: {Device} ) → {Input} Gets the inputs mapped to action that belong to devices. If a VirtualAxis or VirtualAxis2d has a Button that belongs to devices it will be included. local inputMap = InputMap.new():insert(&quot;action&quot;, Enum.KeyCode.Space, Enum.UserInputType.MouseButton1) print(inputMap:getByDevices(&quot;action&quot;, { &quot;Keyboard&quot; })) -- { Enum.KeyCode.Space } print(inputMap:getByDevices(&quot;action&quot;, { &quot;Mouse&quot; })) -- { Enum.UserInputType.MouseButton1 }   "},{"title":"clone​","type":1,"pageTitle":"InputMap","url":"/spark/api/InputMap#clone","content":"&lt;/&gt; InputMap:clone() → InputMap Clones the InputMap.  "},{"title":"serialize​","type":1,"pageTitle":"InputMap","url":"/spark/api/InputMap#serialize","content":"&lt;/&gt; InputMap:serialize() → buffer Returns a serialized version of the InputMap as a buffer. This can be used to save or replicate it. "},{"title":"Actions","type":0,"sectionRef":"#","url":"/spark/api/Actions","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Actions","url":"/spark/api/Actions#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Actions","url":"/spark/api/Actions#new","content":"&lt;/&gt; Actions.new( actions: {string}-- List of action names ) → Actions Creates a new Actions.  "},{"title":"update​","type":1,"pageTitle":"Actions","url":"/spark/api/Actions#update","content":"&lt;/&gt; Actions:update( inputState: InputState, inputMap: InputMap-- The associated InputMap ) → () Updates action states. This should be called once every frame before calling InputState:clear.  "},{"title":"pressed​","type":1,"pageTitle":"Actions","url":"/spark/api/Actions#pressed","content":"&lt;/&gt; Actions:pressed(action: string) → boolean Returns whether action is currently pressed.  "},{"title":"released​","type":1,"pageTitle":"Actions","url":"/spark/api/Actions#released","content":"&lt;/&gt; Actions:released(action: string) → boolean Returns whether action is currently released.  "},{"title":"justPressedSignal​","type":1,"pageTitle":"Actions","url":"/spark/api/Actions#justPressedSignal","content":"&lt;/&gt; Actions:justPressedSignal(action: string) → Signal Returns a Signal that is fired when action is pressed. local disconnect = actions:justPressedSignal(&quot;jump&quot;):connect(function() print(&quot;Jump pressed!&quot;) end) disconnect()   "},{"title":"justReleasedSignal​","type":1,"pageTitle":"Actions","url":"/spark/api/Actions#justReleasedSignal","content":"&lt;/&gt; Actions:justReleasedSignal(action: string) → Signal Returns a Signal that is fired when action is released. local disconnect = actions:justReleasedSignal(&quot;jump&quot;):connect(function() print(&quot;Jump released!&quot;) end) disconnect()   "},{"title":"value​","type":1,"pageTitle":"Actions","url":"/spark/api/Actions#value","content":"&lt;/&gt; Actions:value(action: string) → number Returns the sum of the values of each input bound to action. The value of an input depends on its kind: Buttons have a value of 0 when released and 1 when pressed. Enum.UserInputType.MouseWheel returns the Z value of InputObject.Position. VirtualAxis returns the value of the positive input minus the value of the negative input. 2D axis values like Enum.UserInputType.MouseMovement, Enum.KeyCode.Thumbstick1, or [VirutalAxis2d] will return their magnitude. warning The return value is not clamped to any range.  "},{"title":"axis2d​","type":1,"pageTitle":"Actions","url":"/spark/api/Actions#axis2d","content":"&lt;/&gt; Actions:axis2d(action: string) → Vector2  Returns the sum of Vector2 values of each input bound to action. The value of an input depends on its kind: Buttons and 1D axis values like Enum.UserInputType.MouseWheel or VirtualAxis will always return Vector2.zero. Enum.KeyCode.Thumbstick1 and Enum.KeyCode.Thumbstick2 returns the (X, Y) value of InputObject.Position. Enum.UserInputType.MouseMovement returns the (X, -Y) value of InputObject.Delta. VirtualAxis2d returns Vector2.new(rightValue - leftValue, upValue - downValue). warning The returned Vector2 is not clamped to any range. Consider using Actions:normalizedAxis2d or Actions:clampedAxis2d.  "},{"title":"normalizedAxis2d​","type":1,"pageTitle":"Actions","url":"/spark/api/Actions#normalizedAxis2d","content":"&lt;/&gt; Actions:normalizedAxis2d(action: string) → Vector2  Returns the Actions:axis2d value but normalized. If the value is Vector2.zero, Vector2.zero will be returned.  "},{"title":"clampedAxis2d​","type":1,"pageTitle":"Actions","url":"/spark/api/Actions#clampedAxis2d","content":"&lt;/&gt; Actions:clampedAxis2d(action: string) → Vector2  Returns the Actions:axis2d value but with the length clamped to 1. This allows for Vector2s with a length less than 1 which is useful for gamepad and mobile thumbsticks.  "},{"title":"hold​","type":1,"pageTitle":"Actions","url":"/spark/api/Actions#hold","content":"&lt;/&gt; Actions:hold(action: string) → () → ()-- A function that when called, stops the hold. Presses action manually like a button. It returns a function to cancel the hold. This can be called more than once at the same time and each call will represent a different button press. This is useful to implement mobile buttons. warning The returned function will error if called more than once.  "},{"title":"move​","type":1,"pageTitle":"Actions","url":"/spark/api/Actions#move","content":"&lt;/&gt; Actions:move( action: string, vector: Vector2 ) → Vector2  Increases the axis2d value of action by vector. This value resets after Actions:update is called. This is useful to implement a mobile thumbstick. "}]
"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[775],{23321:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>r});const o=JSON.parse('{"id":"Mobile","title":"Mobile","description":"Spark allows you to activate an action manually. This is especially useful to implement mobile touch controls.","source":"@site/docs/Mobile.md","sourceDirName":".","slug":"/Mobile","permalink":"/spark/docs/Mobile","draft":false,"unlisted":false,"editUrl":"https://github.com/nezuo/spark/edit/master/docs/Mobile.md","tags":[],"version":"current","frontMatter":{},"sidebar":"defaultSidebar","previous":{"title":"Getting Started","permalink":"/spark/docs/GettingStarted"}}');var i=n(74848),c=n(28453);const a={},s="Mobile",l={},r=[];function u(t){const e={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,c.R)(),...t.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"mobile",children:"Mobile"})}),"\n",(0,i.jsx)(e.p,{children:"Spark allows you to activate an action manually. This is especially useful to implement mobile touch controls."}),"\n",(0,i.jsxs)(e.p,{children:["For buttons, you can activate an action with ",(0,i.jsx)(e.code,{children:"Actions:press"}),". Here's how you might implement a mobile button:"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:'local imageButton = Instance.new("ImageButton")\n\nlocal hold = nil\n\nimageButton.InputBegan:Connect(function(inputObject)\n\tif inputObject.UserInputState ~= Enum.UserInputState.Begin then\n\t\t-- UserInputState will be Change if the touch was dragged onto the button.\n\t\treturn\n\tend\n\n\tif hold == nil then\n\t\t-- Press the button every frame before input is updated. If held inputs don\'t matter, you could call press without a loop.\n\t\tlocal connection = RunService.PreRender:Connect(function()\n\t\t\tactions:press("attack")\n\t\tend)\n\n\t\thold = {\n\t\t\tconnection = connection,\n\t\t\tinputObject = inputObject,\n\t\t}\n\tend\nend)\n\nimageButton.InputEnded:Connect(function(inputObject)\n\t-- Only stop the hold if it\'s the same touch that started it.\n\tif hold ~= nil and hold.inputObject == inputObject then\n\t\thold.connection:Disconnect()\n\t\thold = nil\n\tend\nend)\n'})}),"\n",(0,i.jsxs)(e.p,{children:["For 1D/2D axis values like movement, camera movement, or camera zoom, use ",(0,i.jsx)(e.code,{children:"Actions:moveAxis"})," and ",(0,i.jsx)(e.code,{children:"Actions:moveAxis2d"}),"."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-lua",children:'local thumbstickDirection = Vector2.one -- Get this value from your thumbstick.\n\n-- This will increase the 2D axis value of the move action by thumbstickDirection.\n-- It\'s reset every time `Actions:update` is called, so you need to call it every frame.\nactions:moveAxis2d("move", thumbstickDirection)\n\nlocal cameraZoomDelta = 0 -- Could be a value from a pinch motion\n\nactions:moveAxis("cameraZoom", cameraZoomDelta)\n'})})]})}function d(t={}){const{wrapper:e}={...(0,c.R)(),...t.components};return e?(0,i.jsx)(e,{...t,children:(0,i.jsx)(u,{...t})}):u(t)}},28453:(t,e,n)=>{n.d(e,{R:()=>a,x:()=>s});var o=n(96540);const i={},c=o.createContext(i);function a(t){const e=o.useContext(c);return o.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function s(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(i):t.components||i:a(t.components),o.createElement(c.Provider,{value:e},t.children)}}}]);